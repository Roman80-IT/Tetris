Тут `playfield` у цьому випадку є двовимірним масивом, де кожен елемент (рядок) сам по собі є масивом. Розглянемо кожен метод, і як вони взаємодіють.

Ініціалізація ігрового поля

```js
playfield = new Array(PLAYFIELD_ROWS)
  .fill()
  .map(() => new Array(PLAYFIELD_COLUMNS).fill(0));
```

## 1 new Array(PLAYFIELD_ROWS)

- **Опис**: Створює новий масив з `PLAYFIELD_ROWS елементами`.
- **Результат**: Масив, де кожен елемент спочатку є `undefined`. // !!! actually, it is an empty slot !!!

```js
let playfield = new Array(20); // Припустимо, PLAYFIELD_ROWS = 20
console.log(playfield); // [undefined, undefined, undefined, ..., undefined] (20 разів)
```

## 2 .fill()

- **Опис**: Заповнює масив значеннями. Без аргументів заповнює `undefined`.
- **Результат**: Масив з `undefined` значеннями замість початкових `undefined`.

```js
let playfield = new Array(20).fill();
console.log(playfield); // [undefined, undefined, undefined, ..., undefined] (20 разів)
```

## 3 .map(() => new Array(PLAYFIELD_COLUMNS).fill(0))

- **Опис**: Використовується для створення нового масиву на основі існуючого масиву. У цьому випадку, для кожного елемента (рядка) створюється новий масив, який представляє стовпці ігрового поля.
- **Результат**: Кожен елемент основного масиву стає масивом з `PLAYFIELD_COLUMNS елементами`, заповненими `0`.<br>

  **_Розглянемо детальніше цей крок:_**

  **map()**: Метод, що створює новий масив з результатами виклику _функції зворотнього виклику_ для кожного елемента масиву.

```js
playfield = new Array(20).fill().map(() => new Array(10).fill(0));
```

`() => new Array(PLAYFIELD_COLUMNS).fill(0)`: Стрілкова функція, яка виконується для кожного елемента масиву і створює новий масив з `PLAYFIELD_COLUMNS елементами`, заповненими `0`.

## Приклад з поясненням

У нас `PLAYFIELD_ROWS = 20` і `PLAYFIELD_COLUMNS = 10`.

```js
const PLAYFIELD_ROWS = 20;
const PLAYFIELD_COLUMNS = 10;

let playfield = new Array(PLAYFIELD_ROWS)
  .fill()
  .map(() => new Array(PLAYFIELD_COLUMNS).fill(0));

console.table(playfield);
```

- `new Array(PLAYFIELD_ROWS)`:

Створює масив з 20 елементами, заповненими `undefined`.

- `.fill()`:

Заповнює всі елементи` undefined` значеннями `undefined` (це допоміжний крок, щоб далі використовувати `map()`).
`.map(() => new Array(PLAYFIELD_COLUMNS).fill(0))`:

Для кожного елемента основного масиву (20 разів) створює новий масив з `10 елементами`, заповненими `0`.

### Чому потрібний `.fill()`?

метод `fill()` в даному випадку фактично не змінює значень елементів масиву, оскільки вони вже мають значення `undefined`. Проте, цей крок все одно необхідний для того, щоб мати можливість використовувати метод `map()`.

Метод `map()` не виконується для елементів, які залишаються "порожніми" після створення нового масиву з певною довжиною. У **JavaScript** масив може містити "порожні" елементи, які відрізняються від `undefined` і фактично не мають ніякого значення. Ось чому `fill()` є важливим:

#### Без fill()

Якщо ми створюємо масив без заповнення його `fill()`, метод `map()` не буде викликати функцію зворотнього виклику для "порожніх" елементів:

```js
let playfield = new Array(20).map(() => new Array(10).fill(0));
console.table(playfield);
```

В результаті отримаємо масив, який буде містити 20 "порожніх" елементів, тому `map()` не створить всередині нові масиви:

```js
[
<20 empty items>
]
```

#### З fill()

Використання `fill()` заповнює всі елементи масиву, роблячи їх не "порожніми" (навіть якщо вони все ще є `undefined`), що дозволяє `map()` обробляти кожен елемент:

```js
let playfield = new Array(20).fill().map(() => new Array(10).fill(0));
console.table(playfield);
```

Тепер кожен елемент масиву є undefined, але не "порожнім". map() буде викликати функцію зворотнього виклику для кожного елемента:

```js
[
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  ...[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
];
```

#### Висновок

Метод `fill()` використовується для того, щоб переконатися, що кожен елемент масиву є "не порожнім", навіть якщо його значення `undefined`. Це необхідно, щоб метод `map()` міг обробляти кожен елемент масиву і створювати потрібну структуру.

## Пояснення роботи коду

- **Створення основного масиву**:

```js
new Array(PLAYFIELD_ROWS); // [undefined, undefined, ..., undefined] (20 разів)
```

- **Заповнення основного масиву undefined значеннями**:

```js
.fill() // [undefined, undefined, ..., undefined] (20 разів, після виклику map)
```

- **Створення масивів для кожного рядка**:

```js
.map(() => new Array(PLAYFIELD_COLUMNS).fill(0)) // Створює 20 масивів, кожен з яких має 10 елементів, заповнених `0`.
```

## Підсумок

В кінцевому результаті ви отримуєте двовимірний масив `playfield`, де кожен з `20 елементів` основного масиву є масивом з `10 елементів`, заповнених `0`.

```js
[
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // Рядок 0
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // Рядок 1
  ...[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // Рядок 19
];
```
